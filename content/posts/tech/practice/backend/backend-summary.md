---
title: "后端常用技术总结"
date: 2025-05-15T10:00:00+08:00
draft: false
toc: true
featured: true
categories: ["技术/实践/后端"]
tags: ["后端"]
---

## 概述

服务端通用，需要了解和掌握的知识

服务端提供稳定、可靠的服务，给用户快速的体验，保存用户数据，返回用户数据

* 高可用 - 冗余设计，容错处理，自动恢复
* 高并发 - 支持大量请求
* 高性能 - 快速处理单个请求，并减少资源消耗

很多东西都是共性，且长时间不变的，需要去绝对掌握

* 建立体系，从服务底层到业务层，了解各层面做什么，如何协调工作
* 软件基础原理：操作系统、数据结构、数据库
* 软件设计原理：设计思想、模式
* 架构核心原理：原则

## 程序运行

基于操作系统，跑在硬件上，冯诺依曼结构的硬件体系

进程维度，跑在内存中，通过cpu进行计算处理逻辑，对外部设备进行io数据交换

可执行程序，会执行成为进程

![process](/imgs/tech/practice/backend/process.jpg)

进程包含：使用内存和cpu，内存中包含各个区间，可执行代码、堆、栈、进程数据结构

进程是一个死循环，从入口开始，跑各种各样的函数，跳转，会操作堆内存

计算机同时处理很多任务，cpu分时共享技术

所以进程每个都是轮流占用时间片，有调度策略

进程状态：

运行，正在cpu上运行

就绪，拿到除cpu外所有资源，等待cpu

阻塞，因其他资源等待，让出cpu，睡眠等待其他资源成功

进程切换消耗大，实际使用线程来占用cpu

go使用协程，更低的降低线程切换消耗

请求变慢，因为资源有限(内存、cpu、网络)，等待，阻塞

阻塞越多，资源卡住，达到系统极限，系统会宕机，应用崩溃

解决阻塞，就是资源变多，分布式架构，多副本

请求减少，限流，应用消耗减低，降级

并发锁的核心

* 编程语言互斥锁
* 原子操作，信号量cas，封装各种类型cpu
* CPU部分指令 cas，这里现代cpu都包含总线锁，多核cpu保证读写一致

## 数据结构

数组，连续有序内存，相同类型结构

因为连续，知道下标，可以o（1）找到位置

不知道下标，知道值，需要o(N)

链表，地址链接的内存，可能不连续

因为不连续，查找需要遍历，所以o（N）

为了优化查询，插入，删除，异化了链表，各种树就出来了，有序的链表

hash表，底层是数组

下标通过hash函数获取，查找o（1）

哈希冲突，一般链地址法解决，多保存几个值，go的map这样做

栈，先进后出

函数用这个，函数的调用，管理工作区的数据

可以数组，也可以链表实现

队列，先进先出

排队的任务处理

树

数组、链表、栈、队列都是线性表，每个元素一个前驱，一个后继

树是非线性的，一个元素可以多个前驱，多个后继

## java虚拟机跨平台

java如何跨平台，因为虚拟机，封装了多平台实现，不同cpu指令

屏蔽底层不一样的东西

jvm

![jvm](/imgs/tech/practice/backend/jvm.jpg)

JVM，它封装了⼀组⾃定义的字节码指令集，有⾃⼰的程序计数器和执⾏引

擎，像 CPU ⼀样，可以执⾏运算指令。它还像操作系统⼀样有⾃⼰的程序装载与运⾏机制，

内存管理机制，线程及栈管理机制，看起来就像是⼀台完整的计算机，这就是 JVM 被称作

machine（机器）的原因

垃圾回收

可达性分析算法进⾏垃圾对象的识别，扫描标记算法，从栈帧、方法区开始扫描

垃圾回收多种类型

* 识别
* 转移
* 回收
* 屏障

go为什么不分年代垃圾回收

* go内存对象周期短
* 避免年代复杂管理，提高效率

## 网络编程

网络是一个协议，字节，在电缆传输

数据编码转换，计算机，网卡，电缆，路由器，网卡，计算机

DNS

用来寻址

IP地址对应的域名

CDN

加速网络访问

HTTP

http协议，应用层协议，通信

基于TCP协议

传输层协议，可靠传输，重试

传输层协议 TCP 和⽹络层协议 IP 共同构成 TCP/IP 协议栈，

UDP协议

不保证数据传输的可靠性，但是快，许多私有定制协议以UDP为基础来改造，尽最大努力实现可靠（没有TCP那么严格）

网络分层

* 物理层，光缆，电信号
* 数据链路层，数据帧，最大传输单元，帧头有地址，mac地址，物理地址
* 网络层，ip，虚拟地址
* 传输层，tcp，保证数据可靠
* 应用层，http，解析业务数据

![netprotocal](/imgs/tech/practice/backend/netprotocal.jpg)

LB负载均衡

通常dns解析域名后是一个lb的ip，分发请求到各个集群

可以ip层转，也可以更底层转

LB修改数据包里面的头信息，到真正的请求服务端

Nginx 可以在不同的网络层次进行负载均衡，包括 4 层（传输层）和 7 层（应用层）

## 文件系统

硬盘保存文件

文件管理

* 机械硬盘，这里注意磁盘旋转，顺序读写较快，随机慢
* ssd，没有机械操作，读写快

文件系统，操作系统管理硬盘

每个文件若干块，每个块4k

文件控制块，inode，文件的数据块索引，也记录文件权限，所有者等信息

每个inode存储数据块\*4k 最大70G

RAID

硬盘冗余阵列

RAID 的核⼼思路其实是利⽤⽂件系统将数据写⼊硬盘中不同数据块 的特性，将多块硬盘上的空闲空间看做⼀个整体，进⾏数据写⼊

raid0到6 逐渐冗余

实践中，使⽤最多的是 RAID 5，数据被分成 N-1 ⽚并发写⼊ N-1 块硬盘

分布式文件系统

对inode的分布式扩展，也对raid扩展

数据分多片，同时写n台服务器

![hdfs](/imgs/tech/practice/backend/hdfs.jpg)

datanode，管理数据分块写入和读取

namenode，管理数据索引

## 数据库

数据保存系统，提供快速查询，添加等

重要概念：索引，树保存，sql

关系数据库

* 支持sql，语义化分析ast
* 执行引擎

使⽤ PrepareStatement 执⾏ SQL 的好处

* 预处理，提高效率
* 防止sql注入攻击，提前生成sql计划，不会生成新的sql

存储

b+树，每层保存多个节点

b-树

事务，多个日志

非关系数据库

kv，仅保存

## 编程语言

高级语言，对人语义化，提高编程效率

中间会转换多层，成为底层汇编，指令，机器码，二进制等

编程模式

* 过程
* 面向对象
* 函数

现代语言，符合⼈类的习惯和逻辑思 维⽅式

软件编程的本质是程序员⽤代码的⽅式使现实世界的事务运⾏在计算机上，计算机

软件是为了解决现实世界的问题⽽开发出来的，那么软件编程这件事情应该关注的重点是客观

世界的事物本身，⽽不是程序员的思维⽅式或者计算机的指令

更多的理解业务领域，抽象能力，映射能力

业务语言

技术语言

区分开

## 软件设计

### 方法论

建模是什么

对现实世界的抽象，简化，映射成编程可用的业务对象

抽象表达事务的本质规律

认知、理解、映射

把握事物的本质规律和主要特征，正确建造模型和使⽤模型

graph LR
    A[领域问题] -->|分析, 抽象| B[模型]
    B[模型] <-->|设计, 抽象| C[软件系统]
    C -->|开发, 实现| C

4+1视图模型

* 逻辑视图
* 开发视图
* 过程视图
* 物理视图
* 居中的场景视图（所有围绕业务展开）

uml建模

用uml语言抽象业务

软件在开发之初就对软件未来蓝图有个 清晰的认识，从⽽使整个软件开发过程处于可控的范围之内

了解真正的需求，把握本质，规划蓝图，设计扩展性

### 实践

建模的图

类图、序列图、组件图、部署图、⽤例图、状态图和活动 图

* 领域对象
* 流程
* 交互关系
* 部署结构
* 业务用例结构
* 状态流转
* 活动图

### 目的

优秀程序员产出是100倍其他人的

* 可维护
* 高扩展
* 性能
* 安全

优秀

* 设计好
* 效率高
* 稳定安全
* 文档
* 简约设计

应对需求变更最好的办法就是⼀开始的设计就是针对需求变更的，并在开发过 程中根据真实的需求变更不断重构代码，保持代码对需求变更的灵活性

### 开闭原则

隔离设计

公开和私有

定义接口标准，对外标准简单

隐藏细节

开闭原则说：软件实体（模块、类、函数等等）应该对扩展是开放的，对修改是关闭的。

通俗的说就是，软件功能可以扩展，但是软件实体不可以被修改。

粗暴⼀点说，当我们在代码中看到 else 或者 switch/case 关键字的时候，基本可以判 断违反开闭原则了

这里使用策略模式

增加抽象层，根据不同策略，进行不同操作

go里面实现接口

interface

实现开闭原则的关键是抽象

当⼀个模块依赖的是⼀个抽象接⼝的时候，就可以随意对这个抽

象接⼝进⾏扩展，这个时候，不需要对现有代码进⾏任何修改，利⽤接⼝的多态性，通过增加

⼀个新实现该接⼝的实现类，就能完成需求变更。不同场景进⾏扩展的⽅式是不同的，这时候

就会产⽣不同的设计模式，⼤部分的设计模式都是⽤来解决扩展的灵活性问题的

### 依赖倒置

原则：

⾼层模块不应该依赖低层模块，⼆者都应该依赖抽象。

抽象不应该依赖具体实现，具体实现应该依赖抽象。

分层，保证没有具体实现是相互依赖的

go里面，入参通用interface，出参返回interface

每一个分层通过interface来交互

类似的，系统间，通过标准协议接口来交互

编码注意

1\. 应⽤代码中多使⽤抽象接⼝，尽量避免使⽤那些多变的具体实现类。

2\. 不要继承具体类，如果⼀个类在设计之初不是抽象类，那么尽量不要去继承它。对具体类的

继承是⼀种强依赖关系，维护的时候难以改变。

3\. 不要重写（override）包含具体实现的函数。

### 里氏替换

接⼝（抽象类）的多个实现就是多态

关于继承的设计原 则

若对每个类型 T1 的对象 o1，都存在⼀个类型 T2 的对象 o2，使得在所有针对 T2 编写的程序 P 中，⽤ o1 替换 o2 后，程序 P 的⾏为功能不变，则 T1 是 T2 的⼦类型

⼦类型必须能够替换掉它们的基类型

go里面组合了父接口，子接口可以当成父接口来用

⼦类不能⽐⽗类更严格

### 单一责任

一个接口，一个主要功能

一个函数，一个功能

软件设计有两个基本准则：低耦合和⾼内聚

⼀个类，应该只有⼀个引起它变化的原因。

不应该千变万化，便于组合

web开发

每一层只做一件事

![webdev](/imgs/tech/practice/backend/webdev.jpg)

### 接口隔离

公开的东西是标准和少的

隐藏细节

例子：统一缓存服务，可以动态调整缓存读取本地还是远程，sdk提供

这里缓存分为远程控制调用和本地调用

本地使用 get put

远程控制调用 reconfig

接⼝隔离原则说：不应该强迫⽤户依赖他们不需要 的⽅法

以上sdk应该分开两块，一块给用户用，一块给远程控制用，不应该放在一起

接⼝隔离原则，我们可以将⼀个实现类的不同⽅法包装在不同的接⼝中对外暴露

go里面尽量分开设计interface，组合使用

实现了两个interface，但是使用时，可以单独使用interface，这样就隔离了方法

## 设计模式

### 基础

设计模式的核心在于多态的灵活应用

不同的实现

对象封装数据和方法

封装、继承、多态

go 组合，实现

模式是可重复的解决⽅案

设计模式的精髓就是对多态的灵活应⽤

### 应用

框架，帮忙把非业务相关的，可以重复使用的技术类模块，都实现

屏蔽细节，开箱即用

框架是对某⼀类架构⽅案可复⽤的设计与实现

框架需要一套编程规范适配

框架会调⽤我们编写的代码，⽽我们编写的代码则会调⽤ ⼯具完成某些特定的功能，⽐如输出⽇志，进⾏正则表达式匹配等

![devlevel](/imgs/tech/practice/backend/devlevel.jpg)

开发框架

* 开闭原则，隐藏细节，暴露标准
* 依赖倒置原则，通过接口来对接

### 反应式编程框架

让系统不阻塞，及时响应，异步处理

![userreq](/imgs/tech/practice/backend/userreq.jpg)

不阻塞， 反应式编程

* 即时响应，不等待
* 回弹性，可以自行恢复
* 弹性，自动伸缩
* 消息驱动，模块之间靠消息驱动

主流反应式编程框架有 RxJava、Reactor

基于观察者设计模式

http -> mq -> res

\-> async deal

回调获取结果

### 组件设计

边界设计

最大最小限制

⾼内聚、低耦合

内聚

* 复用发布等同原则：软件复⽤的最⼩粒度应该等同于其发布的最⼩粒度

版本号格式：主版本号. 次版本号. 修订号

主版本号升级，表示 组件发⽣了不向前兼容的重⼤修订

次版本号升级，表示组件进⾏了重要的功能修订或者 bug 修复，但是组件是向前兼容的

修订号升级，表示组件进⾏了不重要的功能修订或者 bug 修 复

* 共同封闭原则：我们应该将那些会同时修改，并且为了相同⽬的⽽修改的类放到同⼀个组 件中

不要强迫⼀个组件的⽤户依赖他们不需要的东⻄

* 组件耦合原则：无循环依赖，稳定依赖，稳定抽象

底层永远最大兼容，且稳定不变

### 领域驱动

如果你对⾃⼰要开发的业务领域没有清晰的定义和边界，没有设计系统的领

域模型，⽽仅仅跟着所谓的需求不断开发功能，⼀旦需求来⾃多个⽅⾯，就可能发⽣需求冲

突，或者随着时间的推移，前后功能也会发⽣冲突，这时你越是试图弥补这些冲突，就越是陷

⼊更⼤的冲突之中

开发需要确定目标和边界

业务逻辑的组织⽅式主要是事务脚本模式

Controller→Service→Dao 这样的程序设计模式

事务脚本⼜被称作贫⾎ 模型，没有封装对象数值，只有方法

领域模型模式和事务脚本模式不同。在领域模型模式下，业务逻辑围绕领域模型设计

每个对象是闭环的逻辑，有数值也有方法，维护业务对象关系

领域模型是合并了⾏为和数据的领域的对象模 型

事务脚本被称作贫⾎模型相对应的，领域模型也被称为充⾎模型

如果需求和领域模型冲突，那么这个是伪需求

领域驱动设计

领域是⼀个组织所做的事情以及其包含的⼀切，通俗地说，就是组织的业务范围和做事⽅式，

也是软件开发的⽬标范围。⽐如对于淘宝这样⼀个以电⼦商务为主要业务的组织，C2C 电⼦

商务就是它的领域。领域驱动设计就是从领域出发，分析领域内模型及其关系，进⽽设计软件

系统的⽅法

根据领域，拆分子域，找到界限上下文

![biz-domain](/imgs/tech/practice/backend/biz-domain.jpg)

领域模型对象也被称为实体

实体设计是 DDD 的核⼼所在，⾸先通过业务分析，识别出实体对象

通过 领域实体及其交互完成业务逻辑处理才是 DDD 的核⼼⽬标

业务 - 抽象 - 分层设计代码

解决技术难题

解决业务场景难题

## 架构是什么

不停地演进

简单到负责

单层到多层

注意抽象

### 分布式架构

实际系统面临高并发用户的请求压力

分布式缓存、负载均衡、反向代理与 CDN、分布式消息队列、分布式 =数据库、NoSQL 数据库、分布式⽂件、搜索引擎、微服务等等

水平扩展：集群，分层

服务治理，自动化，自动伸缩(水位线)

每一个集群都有其上限，网关保证上限不会达到

分布式：核心就是分开部署的系统

### 缓存架构

减少不必要的计算

缓存，用已经计算好的结果，返回

减少cpu的消耗，io的消耗

空间换时间

缓存可以分成两种，通读缓存和旁路缓存

* 应用程序 -> 通读缓存 -> 数据源（存缓存由通读缓存自行控制）
* 应用程序 -> 旁路缓存；应用程序 -> 数据源（写数据和存缓存，由客户端控制）

缓存分层

* cdn

内容分发网络，离用户请求近

* 反向代理

缓存，不走后续转发，比如ng的缓存

* 进程内缓存
* 分布式缓存

使用注意点

* 缓存保存内存中，注意时限，大小
* 缓存计算结果
* 缓存节省的资源用于其他系统操作

缓存问题

不一致，脏读

* 过期失效
* 同步更新缓存，延迟双删等

最常用，先更新db后更新缓存

### 异步架构

大规模请求，同步是比较慢的，io等待体验不好

那就直接返回，异步处理，后续通知

一些写操作，缓存无法处理，靠异步

消息队列，异步架构

多生产多消费

![mnprd-consumer](/imgs/tech/practice/backend/mnprd-consumer.jpg)

订阅模式

![1nprd-consumer](/imgs/tech/practice/backend/1nprd-consumer.jpg)

异步好处

* 改善写操作请求的响应时间
* 更容易伸缩
* 削峰填谷，持续消耗cpu资源
* 隔离失败，消费不影响生产
* 解耦

这里注意幂等和重试

通过日志+重试+告警解决

### 负载均衡

网关对后续服务中转

硬件 F5

软件 ng等 其实就是网络转发，网络协议的第几层的转发

dns负载均衡

相同域名不同ip

反向代理负载均衡

ng，4层或7层转发

ip负载均衡

修改网络层协议，报文头

数据链路层负载均衡，避免响应数据经过服务器，承压更大

mac地址

Linux 上实现 IP 负载均衡和链路层负载均衡的技术是 LVS

### 数据存储

大量数据保存

数据库主从复制

读写分离

可以更好的读

* binlog，同步日志

数据库分⽚

分库分表

取模

路由表

全局id

提供数据库中间件，封装细节

NoSQL 数据库

关系数据库处理事务

nosql保存文档数据

NoSQL 数据库主要⽤来解决⼤规模分布式数据的存储问 题

高并发写和读

数据一致性问题，cap

最终数据一致

### 搜索引擎

搜索

elk

elasticsearch

倒排索引：文档中词作为索引，文档作为值，反查

倒排索引缺点

* 存储开销大
* 构建时间长，分词，提取词
* 词汇歧义问题，要更多的分词
* 更新困难，文档更新后，索引更新
* 不适合处理结构化数据

爬虫

![spider](/imgs/tech/practice/backend/spider.jpg)

搜索引擎排序

Google 使⽤了⼀种叫 PageRank 的算法，计算每个⽹⻚的权重，按照权重排序，有了seo

站内排序：权重的计算算法

每一个文档都有权重分数，更新分数，按照分数来排序

空间换时间

Google发明并⾏计算⼯具MapReduce，减少PageRank的计算时间，使⽹⻚排名的更新周期 缩短

### 微服务

单体 - 分层服务 - 微服务

微服务，每个服务都是一个原子的业务单体

优点

* 便于大规模开发
* 系统稳定性高
* 代码管理方便
* 隔断错误
* 系统性能强大

微服务框架原理

* 服务治理
* 通信

![servicemanage](/imgs/tech/practice/backend/servicemanage.jpg)

实践

* 业务需求是最重要的
* 按照业务价值拆分微服务
* 符合拆分原则

![biz-level](/imgs/tech/practice/backend/biz-level.jpg)

中台是一对微服务的矩阵，提供企业级复用能力

### 高性能

⾼并发访问的情况下，系统因为资源不⾜，处理每个请求的时间都会变慢，看起来 就是性能变差

性能指标

* 响应时间
* 并发数
* 吞吐量 HTTP 请求数 HPS、每秒事务数 TPS、每秒查询数 QPS
* 性能计数器

性能测试

* 性能指标测试，验证目标值 这个过程中，随着并发数的增加，吞⼊量 也在增加，但是响应时间变化不⼤。
* 负载测试，最大能力，临界值 这个过程中，随着并发数的增加，吞吐量只有⼩幅的增加，达到最⼤值后，吞吐 量还会下降，⽽响应时间则会不断增加
* 压力测试，系统崩溃的点 这个过程中，吞吐 量迅速下降，响应时间迅速增加，到了系统崩溃点，吞吐量为 0，响应时间⽆穷⼤

![tps-cycle](/imgs/tech/practice/backend/tps-cycle.jpg)

优化

* 用户体验优化，前端屏蔽
* 数据中心优化，更快的数据访问
* 硬件优化，ssd，加内存，加cpu
* 操作系统优化
* 虚拟机优化，语言升级版本，增加效率
* 基础组件优化，db，通信框架
* 架构优化，缓存、消息队列、集群
* 代码优化，代码减少cpu和内存占用，适当空间换时间

### 高可用

集群，多副本，滚动更新，热重启类似，处理完http请求后关闭

网关接管

可用性 = (1-年度不可用时间/年度总时间)*100%

⼀般说来，两个 9 表示系统基本可⽤，年度不可⽤时间⼩于 88 ⼩时；3 个 9 是较⾼可⽤， 年度不可⽤时间⼩于 9 个⼩时；4 个 9 是具有⾃动恢复能⼒的⾼可⽤，年度不可⽤时间⼩于 53 分钟；5 个 9 指极⾼的可⽤性，年度不可⽤时间⼩于 5 分钟

架构

* 冗余备份，db数据，缓存，多副本
* 失败隔离，消息队列
* 限流降级，丢弃请求，返回良好响应，系统非核心，下掉请求
* 异地多活，多个数据中心，通过流量切换来处理，双方进行数据同步，vpn调用数据

预发布，仅内部访问可达，数据参数等跟生产一致

### 安全性

数据安全

敏感字段数据库加密保存

主要使⽤的加密⽅法有三种：单向散列加密、对称加密和⾮对称加密

⽤户密码加密通常使⽤的是单向散列加密，不可解密

明文 -> 单向散列加密(salt) -> 密文

对称加密

明文 -> 密钥 -> 加密算法 -> 密文 -> 密钥 -> 解密算法 -> 明文

非对称

明文 -> 公钥 -> 加密算法 -> 密文 -> 私钥 -> 解密算法 -> 明文

数据传输

http攻击

* sql注入，通过sql预编译
* xss攻击，转义，消毒

第三方包漏洞，扫描代码和review代码进行解决

### 大数据

任何技术都是有需求，然后技术迭代出来

大数据因为互联网发展到一定阶段，数据量太大，需要一种更好的技术来管理和保存数据

⽤更多的计算机组成⼀个集群，提供更多的计算资源，从⽽满⾜更⼤的计算 压⼒要求

⼤数据就是将各种数据统⼀收集起来进⾏计算，发掘其中的价值

大数据的核心在于

* 存
* 算

如何算

* 离线算
* 实时算

如何存

分布式⽂件存储 HDFS 架构

HDFS 可以将数千台服务器组成⼀个统⼀的⽂件存储系统，其中 NameNode 服务器充当⽂件 控制块的⻆⾊，进⾏⽂件元数据管理，即记录⽂件名、访问权限、数据存储地址等信息，⽽真 正的⽂件数据则存储在 DataNode 服务器上

如何算

⼤数据计算 MapReduce 架构

MapReduce 将计算过程分成两个部分，⼀个是 map 过程，每个服务器上会启动多个 map 进 程，map 优先读取本地数据进⾏计算，计算后输出⼀个 集合。另⼀个是 reduce 过程，MapReduce 在每个服务器上都启动多个 reduce 进程，然后对所有 map 输出 的 集合进⾏ shuffle 操作。所谓 shuffle 就是将相同的 key 发送到同⼀个 reduce 进程，在 reduce 中完成数据关联计算

HDFS 和 MapReduce 都是 Hadoop 的组成部分

⼤数据仓库 Hive 架构

数据存和算比较复杂，有很多job，有依赖关系，需要编排，有了框架来复用

hive提供sql分析，生成mapreduce，表保存在hdfs

可以保存大量数据，计算慢，一般t+1数据计算，配合job编排

快速⼤数据计算 Spark 架构

hive，job多复杂，且速度慢

spark在mapreduce基础上，加了内存计算，加快了效率

⼤数据流计算架构 steam

Spark 虽然⽐ MapReduce 快很多，但是⼤多数场景下，计算耗时依然是分钟级别的，这种计 算⼀般被称为⼤数据批处理计算

流处理是实时的，需要storm，批处理改成小批量处理，就是流处理

Spark Streaming 的架构原理是将实时流⼊的数 据切分成⼩的⼀批⼀批的数据，然后将这些⼩的⼀批数据交给 Spark 执⾏

flink

### ai互联网

大数据技术分为

⼀种是⼤数据底层技术，指的就是各种⼤数据计算框架、存储系统、SQL 引擎等等，这些技

术⽐较通⽤，经过⼗⼏年的优胜劣汰，主流的技术产品相对⽐较集中，主要就是我上篇专栏讨

论的 MapReduce、Spark、Hive、Flink 等技术产品

⼀种是⼤数据平台技术，Spark、Hive 这些⼤数据底层技术产品不像我们前⾯讨论过的分布式

缓存、分布式消息队列，在处理⽤户请求的应⽤中，使⽤这些技术产品的 API 接⼝就可以

了

大数据平台三个部分

* 数据采集
* 数据处理
* 数据输出

平台能力 - 智能推荐算法

机器学习：基本上根据不同口径，来计算客群，根据客群找业务

基于⼈⼝统计的推荐是相对⽐较简单的⼀种推荐算法。根据⽤户的基本信息进⾏分类，然后将 商品推荐给同类⽤户。

按照年龄区分人群，uid命中哪个客群，就获取对应商品

基于商品属性的推荐和基于⼈⼝统计的推荐相似，只是根据商品的属性进⾏分类，然后根据商 品分类进⾏推荐。

根据商品分类，区分商品，商品有关联关系，按照用户选择后，关联推荐

基于⽤户的协同过滤推荐，根据⽤户的喜好进⾏⽤户分类，然后根据⽤户分类进⾏推荐

用户行为分析，区分客群

基于商品的协同过滤推荐，则是根据⽤户的喜好对商品进⾏分类，然后根据商品分类进⾏推 荐

根据用户行为，区分商品，把商品关联起来

总之，通过用户行为，区分客群或区分商品，客群与商品有人工编写的对应关系，商品分类有关联

物联网

![lot](/imgs/tech/practice/backend/lot.jpg)

突出实时计算，实时控制，小批量内存计算，加机器学习模型，输出想要的结果

### 区块链

分布式数据库，不容易篡改，数据量会越来越大

讲解下共识机制

* 工作量证明：谁计算快，谁有打包权限
* 权益证明：谁钱多，谁有打包权限
* 委托权益证明：投票选几个节点，有打包权限
* 实用拜占庭容错：自动投票，多数节点同意，有打包权限
* 权威证明：权威节点，有打包权限

去中心，去信任的分布式记账系统，完全分布式

交易或记账

* 有钱包地址，是公钥，记账，代表
* 交易额
* 对方钱包私钥

交易签名，防止伪造

比特币通过每次交易后，记录顺序交易，通过历史检查交易是否能够发生

联盟链存在的基础，多个单位之间不信任，每人负责一个节点，这样大家都有数据，都可以监控对方

区块链的出现，使得低成本，去信任的跨组织合作成为可能

主要解决信任问题

不改变生产力，甚至减低，因为普通数据库更快，更省资源

改变生产关系

## 技术道路

### 修炼

技术路径，能力成长

瓶颈，停滞

解决问题的能力

进阶思路

* 做事情
* 做事情很好
* 主动做事情
* 主动做自己规划的事情
* 引导他人一起做事情

成长步骤

* 承担责任
* 不停的实践
* 熟知业务和场景，以及问题解决方案

### 进阶

影响力

利用互联网

帮助他人

从基础做起，新的技术起点

无捷径

* 承担责任
* 帮助他人

### 落地

找到问题的本质，解决本质

不要不追溯问题，找到根本原因

不要把解决⽅案当作问题的定义，⽽忽略了真正要解决的问题是什么

确定目标是第一要义

你不需要去解决别⼈的问题，你只需要提醒他问题的存在

引导

⻥是最后⼀个看到⽔的，身处问题之中的⼈往往并不觉得有问题

问题 = 期望 - 体验

控制预期

### 沟通

依赖对方解决问题

如果某⼈能够解决问题，⽽他⾃⼰却感受不到问题，那么就让他感受⼀下

立场不同，要换位思考

⽤⼈的最⾼境界是⽤上司

对上，封闭式问题，减少思考，突出自己思考了

对下，开放式问题，开放权限，引导更好的解决

学会上升

直⾔有讳

要批评⽽不要责 难，要对事⽽不要对⼈

以赞成的⽅式表示反对

如果你想解决⼀个⼤家都不关注的问题，那么试试让问题变得更糟

如果你不填⽼师想要的答案，你就是个傻⽠

知道什么重要

不管你在解决什么问题，归根结底都是帮上司解决问题，

### 管理

技术还是管理，同步进行

技术要实践

管理同样要实践

用目标驱动，找到目标，规划路径

OKR

通过对⽬标的制定和对结 果的审核，将团队和员⼯的奋⽃⽬标和公司的战略⽬标统⼀起来，使每个⼈都能理解⾃⼰⼯作 的⽬标是什么，在整个公司战略中的地位是什么，使个⼈更加成为公司整体的⼀部分

过程和目标都重要

通过细化过长，来确定结果

## 总结

依赖倒置：就是中间加一层抽象，上下顺便换，协议不变即可

设计模式：为了复用，适应业务复杂多变，增加一层抽象设计，每次进行实现即可

java运行：先跑jvm，然后一个线程找到main函数跑代码

交往沟通：赞美，平衡温暖，学会听（正向沟通、多听）

技术问题是什么：

* 代码规范，文档管理，发布管理，bug质量管理
* 分布式引进的锁问题
* 缓存一致性问题，分布式缓存的一致性hash
* 分库分表，逻辑分层，物理迁移
* 解决有限资源，提供最佳服务能力的问题
* 安全性问题
* 海量数据问题

学会思考总结，输出
